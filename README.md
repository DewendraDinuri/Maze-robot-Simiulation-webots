# Maze-robot-Simiulation-webots

# ğŸ¤– Webots Dijkstra Maze Robot

This project implements a fast, autonomous maze-solving robot using **Dijkstra's algorithm** inside the Webots simulation environment. The robot calculates the shortest path through a maze from start to goal and follows it using precise motor control. Designed for robotics competitions, educational projects, and AI path planning demonstrations.

---

## ğŸ—‚ï¸ Project Structure

```
webots-dijkstra-maze-robot/
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ controller2/         # Robot movement controller
â”‚   â”‚   â””â”€â”€ controller2.py   # Drives robot using Dijkstra path
â”‚   â””â”€â”€ runThrough/          # Path planning module
â”‚       â””â”€â”€ runthrough.py    # Dijkstraâ€™s algorithm implementation
â”œâ”€â”€ worlds/
â”‚   â””â”€â”€ undergraduate_exampleArena_new.wbt  # Maze simulation world
â”œâ”€â”€ path.txt                 # Output path generated by Dijkstra algorithm
â”œâ”€â”€ README.md                # This documentation file
```

---

## ğŸ¤– Robot Description

- **Simulator**: [Webots](https://cyberbotics.com/)
- **Robot Name**: `robot`
- **Drive Type**: Differential drive (2-wheel)
- **Sensors**: 5 ultrasonic/distance sensors
  - `senF`, `senL1`, `senL2`, `senR1`, `senR2`
- **Motors**: 2 motors attached via `HingeJoint`
- **Controller Language**: Python

> âš ï¸ If motors are not found, use `getDeviceByIndex()` to print available device names in `controller2.py`.

---

## âš™ï¸ How It Works

### 1. Dijkstra Path Calculation (`runthrough.py`)
- Uses a 2D grid to represent the maze: `0 = free space`, `1 = wall`
- Computes the shortest path from `start` to `goal`
- Writes the path to `path.txt` for the robot to follow

### 2. Robot Movement (`controller2.py`)
- Loads the path from `path.txt`
- Drives the robot through the maze based on grid coordinates
- Uses basic velocity control to move forward step-by-step

---

## ğŸš€ Getting Started

### Requirements

- Webots installed
- Python 3.x installed (e.g., via Anaconda)

### Run the Simulation

1. Open Webots and launch the world:
   ```
   worlds/undergraduate_exampleArena_new.wbt
   ```

2. Generate the shortest path using Dijkstra:
   ```bash
   cd controllers/runThrough
   python runthrough.py
   ```

3. In Webots, start the simulation.
   - The robot will use `controller2.py` to move using the generated path.

---

## ğŸ§  Customization

### ğŸ”§ Maze Grid (inside `runthrough.py`)
You can modify your maze like this:

```python
grid = [
    [0, 1, 0, 0],
    [0, 1, 0, 1],
    [0, 0, 0, 0]
]
start = (0, 0)
goal = (2, 3)
```

### ğŸ” Find Actual Motor Names

In `controller2.py`, to debug motor names:

```python
for i in range(robot.getNumberOfDevices()):
    print(robot.getDeviceByIndex(i).getName())
```

Then set:
```python
left_motor = robot.getDevice("actual_left_motor_name")
right_motor = robot.getDevice("actual_right_motor_name")
```

---

## ğŸ“¸ Preview

> Maze and robot in Webots (add screenshot later)

```
[Insert maze_view.png here]
```

---

## ğŸ‘©â€ğŸ’» Author

**Dinuri Dewendra**  
Undergraduate â€“ Software Engineering  
University of Westminster (IIT Affiliated)  
GitHub: [github.com/your-username](https://github.com/your-username)

---

## ğŸ“œ License

This project is licensed under the MIT License.
